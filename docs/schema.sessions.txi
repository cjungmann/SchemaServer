@node Sessions
@chapter Sessions

Sessions keep track of individual users in order to allow them
to return to work already done.  Upon the establishment of a new
session, a record is automatically created in @dfn{SSYS_SESSION},
and optionally in a application-defined support table.

@menu
* Session Types::             Explain the basic session types
* Simple Session Type::       Unqualified session
* Identity Session Type::     Session for authorized or subsection
                              interactions
* Salted Passwords::          Describes how to use and how @command{schema.fcgi}
                              implements saveing salted passwords.
* Establish Session Type::    Allow unauthorized access during login
                              interactions
* Prepare Login Interaction:: Set up procedures and response modes
                              for authorizing access by login.
@end menu

@node Session Types
@section Session Types

There are @dfn{simple} and @dfn{identity} sessions.

@subheading Simple Session

A simple session is established silently when specified.  This
type of session is used for multiple-step interactions that do
not require authorization.

@subheading Identity Session

An identity session is used when it is important to establish
the user, or at least the user's intentions.  It is most
commonly used when an application requires that a user login


@node Simple Session Type
@section Simple Session Type

A simple session is established by a single SRM instruction,
@code{$session-type : simple}  This instruction will use an
established session or create a new one if needed.

The primary reason for establishing a simple session is to
track multiple-step interactions.  In particular, an import
interaction consists of three steps:

@enumerate
@item
Upload the file
@item
Review the upload
@item
Commit or abandon the upload.
@end enumerate


@node Identity Session Type
@section Identity Session Type

An identity session is primarily for logged-in, authorized
access to an application.  It can also be used to set 
session variables that help direct user interactions.

The main characteristic of an identity session is that
the SRM file will include a remedy for an expired session.

@example
$session-type        : identity
$test_authorized     : App_Session_Bespoke_Checker
$jump_not_authorized : login.srm
@end example

The @code{$test_authorized} instruction names the procedure
that can test if a session is still valid.  The procedure
takes a single parameter, an INT UNSIGNED with the session
id, and returns via a query result, 0 for an expired or
invalid session, or non-zero for a valid sessions.

@code{$jump_not_authorized} specifies the URL to which the
user will be directed if the session is not valid.

@node Salted Passwords
@section Salted Passwords

To eliminate the need for a script processor, it was necessary
to implement a password decryption utility into @command{schema.fcgi}

I'm leaving a bunch out, but the real reason I started this section
is to document the @code{drop-salt} instruction

@example
create_login
   type        : form-new
   schema-proc : App_User_Create
   drop-salt
      name   : table-salt  # optional value, default dropped-salt
      length : 48          # optional value, default 32
@end example

   
@node Establish Session Type
@section Establish Session Type

Commonly, an application will put the session specifications
in a common shared file so all interactions will behave
consistently.  For an identity session type, this means that
interactions will be forbidden unless the user's identity is
established.

This poses a problem for collecting authorization values:
the @command{schema.fcgi} program will normally refuse to
serve the form needed to submit them, and the interaction
that confirms them.  Changing the session type to @emph{none}
would not work because the session established upon entry
to @command{schema.fcgi} would be abandoned, losing the
connection to the 

In this type of case, the global $session-type should be
overridden by a local $session-type.  Consider the following
example:

@example
main
   type         : form-new
   session-type : establish
   schema-proc  : App_Session_Login
   form-action  : ?login
   title        : Log into the application

login
   type         : form-result
   session-type : establish
   procedure    : App_Session_Login
   jump         : mainapp.srm
@end example


@node Prepare Login Interaction
@section Prepare Login Interaction

The login process requires special handling.  The @code{session-type}
is set to @code{identity}, in which state @command{schema.fcgi}
will refuse access.

@example

-- Make sure the @code{pword} field is long enough to hold the
-- hash result.
CREATE TABLE User
(
   id    INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
   email VARCHAR(128) UNIQUE,
   pword CHAR(32),

   INDEX(email)
);
   
CREATE TABLE Session_Info
(
   id_session INT UNSIGNED NULL,
   id_email   INT UNSIGNED NULL,

   INDEX(id_session)
);

CREATE PROCEDURE App_Login_Submit(email VARCHAR(128), pword VARCHAR(24))
BEGIN
   DECLARE email_id INT UNSIGNED;

   -- Test the login credentials:
   SELECT e.id INTO email_id
     FROM EmailList e
    WHERE e.email = email
      AND e.pword = md5(pword)
    LIMIT 1;

   -- One of three SELECT queries, depending on test outcome:
   IF email_id IS NOT NULL THEN
   INSERT INTO Session_Info(id_session, id_email)
          VALUES(@@session_confirmed_id, id_email);

   -- (also checking for database error)
      IF ROW_COUNT() = 1 THEN
         SELECT 0 AS error, 'Success' AS msg;
      ELSE
         SELECT 1 AS error, 'Database error' AS msg;
      END IF;
   ELSE
      -- A failed login attempt should also invalidate any current session.
      -- This is a lazy abandon, the system's session record is left to expire.
      CALL App_Session_Abandon(@@session_confirmed_id);
      SELECT 1 AS error, 'email/password mismatch' AS msg;
   END IF;
END $$
@end example

To ensure that authorization checking occurs for all response modes,
the best practice is to put the session instructions in a shared
mode in a auto-loaded or included SRM file:

@file{common.srm}
@example
$session-type        : identity
$test-authorized     : App_Check_Authorized;
$jump-not-authorized : email.srm?login
@end example

This the the @file{email.srm} file.  Pay attention to the follwing
instructions that handle the special needs of a login interaction:

@table @strong
@item type : form-new
This mode type returns a resultset with a schema for building an
empty form in which the login information will be entered.
@item session-type : establish
This relaxes the identity session type to allow the form to be
returned and its response to be processed.  Without this, @command{schema.fcgi}
would refuse to return the login form.
@item type : form-result
This special mode type returns a true or false query result,
with the @code{jump} instruction in login_submit will be honored
if the procedure returns a non-zero result.
@end table

@file{email.srm}
@example
$include : common.srm
# The session-type : establish overrides the authorization jump
# response from the previous two instructions.
login
   type         : form-new
   session-type : establish
   schema-proc  : App_Login_Submit
   form-action  : ?login_submit

# In this response mode, the type, session-type, and jump instructions,
# together cause a unique response from schema.fcgi.
login_submit
   type         : form-result
   session-type : establish
   procedure    : App_Login_Submit
   jump         : email.srm?home
@end example
